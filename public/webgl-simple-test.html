<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>WebGL å¿«é€Ÿæµ‹è¯•</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 800px;
      margin: 50px auto;
      padding: 20px;
      background: #1a1a1a;
      color: #fff;
    }
    h1 { color: #4CAF50; }
    .result {
      padding: 15px;
      margin: 10px 0;
      border-radius: 5px;
      font-size: 16px;
    }
    .success {
      background: #4CAF50;
      color: white;
    }
    .error {
      background: #f44336;
      color: white;
    }
    .info {
      background: #2196F3;
      color: white;
    }
    canvas {
      width: 400px;
      height: 300px;
      border: 2px solid #4CAF50;
      display: block;
      margin: 20px auto;
      background: #000;
    }
    code {
      background: #333;
      padding: 2px 6px;
      border-radius: 3px;
    }
  </style>
</head>
<body>
  <h1>ğŸ§ª WebGL å¿«é€Ÿæ£€æµ‹</h1>
  
  <div id="results"></div>
  
  <canvas id="canvas"></canvas>
  
  <script>
    const results = document.getElementById('results');
    
    function addResult(text, className) {
      const div = document.createElement('div');
      div.className = `result ${className}`;
      div.innerHTML = text;
      results.appendChild(div);
    }
    
    // 1. æ£€æµ‹ Electron ç‰¹å¾
    const hasElectron = !!(window.electron || window.electronAPI || window.process);
    addResult(
      hasElectron 
        ? 'âŒ æ£€æµ‹åˆ° Electron ç‰¹å¾ - ä¼ªè£…å¤±è´¥ï¼' 
        : 'âœ… æœªæ£€æµ‹åˆ° Electron ç‰¹å¾ - ä¼ªè£…æˆåŠŸï¼',
      hasElectron ? 'error' : 'success'
    );
    
    // 2. æ£€æµ‹ Chrome å¯¹è±¡
    const hasChrome = !!window.chrome;
    addResult(
      hasChrome 
        ? 'âœ… Chrome å¯¹è±¡å­˜åœ¨' 
        : 'âŒ Chrome å¯¹è±¡ä¸å­˜åœ¨',
      hasChrome ? 'success' : 'error'
    );
    
    // 3. æ£€æµ‹ WebDriver
    addResult(
      navigator.webdriver === false 
        ? 'âœ… WebDriver: false (æ­£å¸¸)' 
        : 'âŒ WebDriver: ' + navigator.webdriver,
      navigator.webdriver === false ? 'success' : 'error'
    );
    
    // 4. æ£€æµ‹ User-Agent
    const isChrome = navigator.userAgent.includes('Chrome') && !navigator.userAgent.includes('Electron');
    addResult(
      isChrome 
        ? 'âœ… User-Agent: Chrome (æ­£å¸¸)' 
        : 'âŒ User-Agent: ' + navigator.userAgent,
      isChrome ? 'success' : 'error'
    );
    
    // 5. æ£€æµ‹ Vendor
    addResult(
      navigator.vendor === 'Google Inc.' 
        ? 'âœ… Vendor: Google Inc.' 
        : 'âš ï¸ Vendor: ' + navigator.vendor,
      navigator.vendor === 'Google Inc.' ? 'success' : 'error'
    );
    
    // 6. æµ‹è¯• WebGL
    const canvas = document.getElementById('canvas');
    let gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    
    if (!gl) {
      addResult('âŒ WebGL 1.0: ä¸å¯ç”¨ - è¿™å°±æ˜¯é—®é¢˜æ‰€åœ¨ï¼', 'error');
    } else {
      addResult('âœ… WebGL 1.0: å¯ç”¨', 'success');
      
      // æµ‹è¯• WebGL 2.0
      const gl2 = canvas.getContext('webgl2');
      addResult(
        gl2 ? 'âœ… WebGL 2.0: å¯ç”¨' : 'âš ï¸ WebGL 2.0: ä¸å¯ç”¨',
        gl2 ? 'success' : 'info'
      );
      
      // è·å– WebGL ä¿¡æ¯
      addResult(`ğŸ“Š GL Vendor: <code>${gl.getParameter(gl.VENDOR)}</code>`, 'info');
      addResult(`ğŸ“Š GL Renderer: <code>${gl.getParameter(gl.RENDERER)}</code>`, 'info');
      addResult(`ğŸ“Š GL Version: <code>${gl.getParameter(gl.VERSION)}</code>`, 'info');
      
      // æµ‹è¯• Debug æ‰©å±•
      const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
      if (debugInfo) {
        const vendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
        const renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
        addResult(`ğŸ® GPU Vendor: <code>${vendor}</code>`, 'info');
        addResult(`ğŸ® GPU Renderer: <code>${renderer}</code>`, 'info');
      }
      
      // ç»˜åˆ¶æµ‹è¯•ä¸‰è§’å½¢
      try {
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        
        const vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader, `
          attribute vec2 position;
          void main() { gl_Position = vec4(position, 0.0, 1.0); }
        `);
        gl.compileShader(vertexShader);
        
        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader, `
          precision mediump float;
          void main() { gl_FragColor = vec4(0.3, 0.8, 0.3, 1.0); }
        `);
        gl.compileShader(fragmentShader);
        
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        gl.useProgram(program);
        
        const vertices = new Float32Array([0, 0.5, -0.5, -0.5, 0.5, -0.5]);
        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        
        const position = gl.getAttribLocation(program, 'position');
        gl.enableVertexAttribArray(position);
        gl.vertexAttribPointer(position, 2, gl.FLOAT, false, 0, 0);
        
        gl.drawArrays(gl.TRIANGLES, 0, 3);
        
        addResult('âœ… WebGL æ¸²æŸ“æµ‹è¯•: æˆåŠŸï¼ˆåº”è¯¥çœ‹åˆ°ç»¿è‰²ä¸‰è§’å½¢ï¼‰', 'success');
      } catch (e) {
        addResult('âŒ WebGL æ¸²æŸ“å¤±è´¥: ' + e.message, 'error');
      }
    }
    
    // æœ€ç»ˆåˆ¤æ–­
    const allGood = !hasElectron && hasChrome && navigator.webdriver === false && gl;
    
    if (allGood) {
      addResult('ğŸ‰ æ‰€æœ‰æ£€æµ‹é€šè¿‡ï¼åº”ç”¨ä¼ªè£…æˆåŠŸï¼Œå¯ä»¥è®¿é—®æ¸¸æˆç½‘ç«™äº†ï¼', 'success');
    } else {
      addResult('âš ï¸ éƒ¨åˆ†æ£€æµ‹æœªé€šè¿‡ï¼Œå¯èƒ½ä»ç„¶æ— æ³•è®¿é—®æŸäº›ç½‘ç«™', 'error');
    }
  </script>
</body>
</html>
